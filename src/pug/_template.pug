include _mixin
block variables

doctype html
html
  head
    meta(charset='utf-8')

    title #{title}
    block description

    meta(http-equiv='X-UA-Compatible', content='IE=edge')
    meta(name='viewport', content='width=device-width, initial-scale=1, maximum-scale=1')

    // Template Basic Images Start
    link(rel="apple-touch-icon", sizes="57x57", href="/apple-icon-57x57.png")
    link(rel="apple-touch-icon", sizes="60x60", href="/apple-icon-60x60.png")
    link(rel="apple-touch-icon", sizes="72x72", href="/apple-icon-72x72.png")
    link(rel="apple-touch-icon", sizes="76x76", href="/apple-icon-76x76.png")
    link(rel="apple-touch-icon", sizes="114x114", href="/apple-icon-114x114.png")
    link(rel="apple-touch-icon", sizes="120x120", href="/apple-icon-120x120.png")
    link(rel="apple-touch-icon", sizes="144x144", href="/apple-icon-144x144.png")
    link(rel="apple-touch-icon", sizes="152x152", href="/apple-icon-152x152.png")
    link(rel="apple-touch-icon", sizes="180x180", href="/apple-icon-180x180.png")
    link(rel="icon", type="image/png", sizes="192x192", href="/android-icon-192x192.png")
    link(rel="icon", type="image/png", sizes="32x32", href="/favicon-32x32.png")
    link(rel="icon", type="image/png", sizes="96x96", href="/favicon-96x96.png")
    link(rel="icon", type="image/png", sizes="16x16", href="/favicon-16x16.png")
    link(rel="manifest", href="/manifest.json")
    meta(name="msapplication-TileColor", content="#ffffff")
    meta(name="msapplication-TileImage", content="/ms-icon-144x144.png")
    meta(name="theme-color", content="#ffffff")
    // Template Basic Images End

    // Custom Browsers Color Start
    block color
    // Custom Browsers Color End

    style(type="text/css").
      .preloader {
        display: flex;
        margin: auto;
        position: fixed;
        width: 100%;
        height: 100%;
        background-color: #ccc;
      }

      .preloader img {
        width: 200px;
        height: 100px;
        margin: auto;
      }

    <!--[if lt IE 9]>
      script(src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.2/html5shiv.min.js")
    <![endif]-->


  body.body
    .preloader
      img(src="img/preloader.svg" alt="preloader")

    // Custom HTML Start
    block content
    // Custom HTML End

    // Loading JS Start
    block js
    // Loading JS End

    // Loading CSS Start
    block styles
    // Loading CSS End

    //  Google fonts cdn
    script.
      WebFontConfig = {
        google: {
          families: ['Lato:300,400i,600,700', 'Open+Sans:400,700']
        }
      };
      (function () {
        var wf = document.createElement('script');
        wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
          '://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
        wf.type = 'text/javascript';
        wf.async = 'true';
        var s = document.getElementsByTagName('script')[0];
        s.parentNode.insertBefore(wf, s);
      })();


    link(rel='preload', href='css/index.css', as='style', onload="this.rel='stylesheet'")
    noscript
      link(rel='stylesheet', href='css/index.css')
    script.
      /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
      /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
      (function (w) {
        "use strict";
        /* exported loadCSS */
        var loadCSS = function (href, before, media) {
          // Arguments explained:
          // `href` [REQUIRED] is the URL for your CSS file.
          // `before` [OPTIONAL] is the element the script should use as a reference for injecting our stylesheet <link> before
          // By default, loadCSS attempts to inject the link after the last stylesheet or script in the DOM. However, you might desire a more specific location in your document.
          // `media` [OPTIONAL] is the media type or query of the stylesheet. By default it will be 'all'
          var doc = w.document;
          var ss = doc.createElement("link");
          var ref;
          if (before) {
            ref = before;
          }
          else {
            var refs = ( doc.body || doc.getElementsByTagName("head")[0] ).childNodes;
            ref = refs[refs.length - 1];
          }
          var sheets = doc.styleSheets;
          ss.rel = "stylesheet";
          ss.href = href;
          // temporarily set media to something inapplicable to ensure it'll fetch without blocking render
          ss.media = "only x";

          // wait until body is defined before injecting link. This ensures a non-blocking load in IE11.
          function ready (cb) {
            if (doc.body) {
              return cb();
            }
            setTimeout(function () {
              ready(cb);
            });
          }

          // Inject link
          // Note: the ternary preserves the existing behavior of "before" argument, but we could choose to change the argument to "after" in a later release and standardize on ref.nextSibling for all refs
          // Note: `insertBefore` is used instead of `appendChild`, for safety re: http://www.paulirish.com/2011/surefire-dom-element-insertion/
          ready(function () {
            ref.parentNode.insertBefore(ss, ( before ? ref : ref.nextSibling ));
          });
          // A method (exposed on return object for external use) that mimics onload by polling document.styleSheets until it includes the new sheet.
          var onloadcssdefined = function (cb) {
            var resolvedHref = ss.href;
            var i = sheets.length;
            while (i--) {
              if (sheets[i].href === resolvedHref) {
                return cb();
              }
            }
            setTimeout(function () {
              onloadcssdefined(cb);
            });
          };

          function loadCB () {
            if (ss.addEventListener) {
              ss.removeEventListener("load", loadCB);
            }
            ss.media = media || "all";
          }

          // once loaded, set link's media back to `all` so that the stylesheet applies once it loads
          if (ss.addEventListener) {
            ss.addEventListener("load", loadCB);
          }
          ss.onloadcssdefined = onloadcssdefined;
          onloadcssdefined(loadCB);
          return ss;
        };
        // commonjs
        if (typeof exports !== "undefined") {
          exports.loadCSS = loadCSS;
        }
        else {
          w.loadCSS = loadCSS;
        }
      }(typeof global !== "undefined" ? global : this));
      /*! loadCSS rel=preload polyfill. [c]2017 Filament Group, Inc. MIT License */
      /*! loadCSS rel=preload polyfill. [c]2017 Filament Group, Inc. MIT License */
      (function (w) {
        // rel=preload support test
        if (!w.loadCSS) {
          return;
        }
        var rp = loadCSS.relpreload = {};
        rp.support = function () {
          try {
            return w.document.createElement("link").relList.supports("preload");
          } catch (e) {
            return false;
          }
        };
        // loop preload links and fetch using loadCSS
        rp.poly = function () {
          var links = w.document.getElementsByTagName("link");
          for (var i = 0; i < links.length; i++) {
            var link = links[i];
            if (link.rel === "preload" && link.getAttribute("as") === "style") {
              w.loadCSS(link.href, link, link.getAttribute("media"));
              link.rel = null;
            }
          }
        };
        // if link[rel=preload] is not supported, we must fetch the CSS manually using loadCSS
        if (!rp.support()) {
          rp.poly();
          var run = w.setInterval(rp.poly, 300);
          if (w.addEventListener) {
            w.addEventListener("load", function () {
              rp.poly();
              w.clearInterval(run);
            });
          }
          if (w.attachEvent) {
            w.attachEvent("onload", function () {
              w.clearInterval(run);
            });
          }
        }
      }(this));


